// -*- C++ -*-
// Integration utilities for the C++ library testsuite.
//
// Copyright (C) 2011, 2012 Free Software Foundation, Inc.
//
// This file is part of the GNU ISO C++ Library.  This library is free
// software; you can redistribute it and/or modify it under the
// terms of the GNU General Public License as published by the
// Free Software Foundation; either version 3, or (at your option)
// any later version.
//
// This library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License along
// with this library; see the file COPYING3.  If not see
// <http://www.gnu.org/licenses/>.
//
//Provides test example of using integration suite with Hermite polynomials
//Written by Jason Dick

#include <iostream>
#include <cmath>
#include <tr1/cmath>
#include <functional>
#include <stdexcept>
#include <sstream>
#include <string>

//#include "simple_integrate.h"
#include "factorial_table.h"
#include "integration.h"

using namespace std;
using namespace __gnu_test;

//Function which should integrate to 1 for n1=n2, 0 otherwise.
double normalized_hermite(int n1, int n2, double x)
{
  double lnnorm_fact = 0.5*(log(M_PI) + (n1+n2)*log(2.)
                     + lgamma(n1+1) + lgamma(n2+1));
  return tr1::hermite(n2,x)*exp(-x*x-lnnorm_fact)*tr1::hermite(n1,x);
}

int main()
{
  const double infty = numeric_limits<double>::infinity();

  //Neverending loop: runs until integration fails
  for (int n1 = 0; ; n1++)
  {
    for (int n2 = 0; n2 <= n1; n2++)
    {
      function<double(double)> func(bind(&normalized_hermite, n1, n2,
                                         placeholders::_1));
      double integ_precision = numeric_limits<double>::epsilon()*1000;
      double comp_precision = integ_precision*10.;
      double integration_result, integration_error;

      typedef pair<double&,double&> ret_type;
      ret_type{integration_result,integration_error}
          = integrate(func, -infty, infty, integ_precision, 0.);

      if (n1 == n2)
      {
        //integration_result should be 1, throw error if differs from one by
        //more than integration precision (with an additional fudge factor in
        //case integration isn't quite that accurate)
        if (fabs(1.-integration_result) > comp_precision)
        {
          stringstream ss;
          ss.precision(-int(log10(numeric_limits<double>::epsilon())));
          ss << "Integration failed at n1=" << n1 << ", n2=" << n2
             << ", returning result " << integration_result
             << " instead of the expected 1" << endl;
          throw logic_error(ss.str());
        }
      }
      else
      {
        //integration_result should be 0, throw error if differs from zero by
        //more than integration precision (with an additional fudge factor in
        //case integration isn't quite that accurate)
        if (fabs(integration_result) > comp_precision)
        {
          stringstream ss;
          ss.precision(14);
          ss << "Integration failed at n1=" << n1 << ", n2=" << n2
             << ", returning result " << integration_result
             << " instead of the expected 0" << endl;
          throw logic_error(ss.str());
        }
      }
    }
    cout << "Integration successful for hermite polynomials up to n=" << n1
         << endl;
  }  
}
